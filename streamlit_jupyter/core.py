# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['IN_IPYTHON', 'tqdm', 'StreamlitPatcher']

# %% ../nbs/00_core.ipynb 2
import logging
import time
import typing as tp

import streamlit
from fastcore.basics import in_ipython, listify, noop, patch, patch_to
from fastcore.test import test_fail, test_eq
from IPython.utils.capture import capture_output
from nbdev.showdoc import show_doc


import functools

import IPython.display

# %% ../nbs/00_core.ipynb 3
# module obljects that we will be importing
IN_IPYTHON = in_ipython()

# %% ../nbs/00_core.ipynb 5
import inspect


class StreamlitPatcher:
    """class to patch streamlit functions for displaying content in jupyter notebooks"""

    def __init__(self):
        self.is_registered: bool = False
        self.registered_methods: tp.Set[str] = set()

    def jupyter(self):
        """
        Registers the current `tqdm` class with
            streamlit.
            ( write
              markdown

            )
        """
        # patch streamlit methods from MAPPING property dict
        for method_name, wrapper in self.MAPPING.items():
            self._wrap(method_name, wrapper)

        # patch stqdm

        self.is_registered = True

    @staticmethod
    def _get_streamlit_methods():
        """get all streamlit methods"""
        return [attr for attr in dir(st) if not attr.startswith("_")]

# %% ../nbs/00_core.ipynb 10
@patch_to(StreamlitPatcher, cls_method=False)
def _wrap(cls, method_name: str, wrapper: tp.Callable, forced_wrapper_name: tp.Optional[str] = '') -> None:
    """make a streamlit method jupyter friendly

    Parameters
    ----------
    method_name : str
        which method to jupyterify
    wrapper : tp.Callable
        wrapper function to use
    """
    if IN_IPYTHON:  # only patch if in jupyter
        if hasattr(wrapper, "__name__"):
            print(f"wrapping 'streamlit.{method_name}' with 'streamlit_jupyter.core.{wrapper.__name__}'")
        else:
            print(f"wrapping 'streamlit.{method_name}' with 'streamlit_jupyter.core.{wrapper}'")

        trg = getattr(streamlit, method_name)
        setattr(streamlit, method_name, wrapper(trg))
        cls.registered_methods.add(method_name)
    else:  # otherwise do nothing
        pass

# %% ../nbs/00_core.ipynb 15
def _display(arg: tp.Any) -> None:
    if isinstance(arg, str):
        IPython.display.display(IPython.display.Markdown(arg))
    else:
        IPython.display.display(arg)


def _st_write(func_to_decorate):
    """Decorator to display objects passed to Streamlit in Jupyter notebooks."""

    @functools.wraps(func_to_decorate)
    def wrapper(*args, **kwargs):
        for arg in args:
            _display(arg)

    return wrapper

# %% ../nbs/00_core.ipynb 21
def _st_heading(func_to_decorate: tp.Callable, tag: str) -> tp.Callable:
    """Decorator to display objects passed to Streamlit in Jupyter notebooks."""

    @functools.wraps(func_to_decorate)
    def wrapper(*args, **kwargs):
        if len(args) == 1:
            body = args[0]
        elif len(args) == 2:
            body, anchor = args
        elif len(args) > 2:
            raise ValueError(
                f"Too many positional arguments: {len(args)}, {func_to_decorate.__name__} only accepts 2"
            )
        elif len(args) == 0:
            if "body" not in kwargs:
                raise ValueError(
                    f"Missing required argument: body, {func_to_decorate.__name__} requires a body"
                )
            body = kwargs["body"]

        if isinstance(body, str):
            _display(f"{tag} {body}")
        else:
            raise TypeError(
                f"Unsupported type: {type(body)}, {func_to_decorate.__name__} only accepts strings"
            )

    return wrapper

# %% ../nbs/00_core.ipynb 28
def _st_type_check(
    func_to_decorate: tp.Callable, allowed_types: tp.Union[tp.Type , tp.Collection[tp.Type]]
) -> tp.Callable:
    """Decorator to display objects passed to Streamlit in Jupyter notebooks."""
    allowed_types = listify(allowed_types)  # make sure it's a list

    @functools.wraps(func_to_decorate)
    def wrapper(*args, **kwargs):
        if len(args) == 1:
            body = args[0]
        elif len(args) > 1:
            raise ValueError(
                f"Too many positional arguments: {len(args)}, {func_to_decorate.__name__} only accepts 2"
            )
        elif len(args) == 0:
            if kwargs:
                raise NotImplementedError(
                    f"kwargs not supported yet, 'streamlit_data_science.utils._wrap_st_type_check' only accepts positional arguments"
                )
            else:
                raise ValueError(f"at least one positional argument is required")

        if type(body) in allowed_types:
            _display(body)
        else:
            raise TypeError(
                f"Unsupported type: {type(body)}, {func_to_decorate.__name__} only accepts {allowed_types}"
            )

    if IN_IPYTHON:
        return wrapper
    else:
        return func_to_decorate

# %% ../nbs/00_core.ipynb 33
@patch_to(StreamlitPatcher, as_prop=True)
def MAPPING(cls) -> tp.Dict[str, tp.Callable]:
    """mapping of streamlit methods to their jupyter friendly versions"""
    return {
        "write": _st_write,
        "title": functools.partial(_st_heading, tag="#"),
        'header': functools.partial(_st_heading, tag="##"),
        'subheader': functools.partial(_st_heading, tag="###"),  
        'markdown': functools.partial(_st_type_check, allowed_types=str)
         } 

# %% ../nbs/00_core.ipynb 37
if IN_IPYTHON:
    from tqdm.notebook import tqdm
else:
    from stqdm import stqdm as tqdm

tqdm = tqdm  # make this available in the module namespace
